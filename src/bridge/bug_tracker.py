"""
Automated bug tracking and error collection system.

Captures errors, system state, and context for debugging.
Stores locally in SQLite for privacy, with optional GitHub issue creation.
"""

from __future__ import annotations

import json
import sqlite3
import sys
import threading
import time
import traceback
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List
from dataclasses import dataclass, asdict
from enum import Enum, auto

import requests
import structlog
import platform

logger = structlog.get_logger()


class BugSeverity(Enum):
    """Bug severity levels."""
    CRITICAL = "critical"      # Crash, data loss, security
    HIGH = "high"              # Feature broken, bad UX
    MEDIUM = "medium"          # Annoyance, workaround exists
    LOW = "low"                # Cosmetic, minor
    INFO = "info"              # For telemetry


class BugStatus(Enum):
    """Bug tracking status."""
    NEW = "new"
    TRIAGED = "triaged"
    IN_PROGRESS = "in_progress"
    FIXED = "fixed"
    CLOSED = "closed"
    DUPLICATE = "duplicate"


@dataclass
class SystemSnapshot:
    """System state at time of error."""
    timestamp: str
    python_version: str
    platform: str
    platform_version: str
    cpu_count: int
    memory_available: Optional[int]
    disk_free: Optional[int]
    audio_devices: Optional[List[Dict]]
    config_hash: Optional[str]
    session_id: Optional[str]
    uptime_seconds: Optional[float]
    
    @classmethod
    def capture(cls, config=None, session_id=None) -> SystemSnapshot:
        """Capture current system state."""
        import psutil
        
        # Get audio devices if available
        audio_devices = None
        try:
            import sounddevice as sd
            devices = sd.query_devices()
            audio_devices = [
                {"name": d.get("name"), "channels": d.get("max_input_channels", 0)}
                for d in devices
            ]
        except (ImportError, Exception) as e:
            import structlog
            logger = structlog.get_logger()
            logger.warning("bug_tracker.audio_devices_failed", error=str(e))
            pass
        
        # Config hash for detecting config-related bugs
        config_hash = None
        if config:
            try:
                import hashlib
                config_str = json.dumps(config.model_dump(), sort_keys=True)
                config_hash = hashlib.md5(config_str.encode()).hexdigest()[:8]
            except (json.JSONDecodeError, TypeError, AttributeError, Exception) as e:
                import structlog
                logger = structlog.get_logger()
                logger.warning("bug_tracker.config_hash_failed", error=str(e))
                pass
        
        # Uptime if tracker has start time
        uptime = None
        if hasattr(BugTracker, '_start_time'):
            uptime = (datetime.now() - BugTracker._start_time).total_seconds()
        
        return cls(
            timestamp=datetime.now().isoformat(),
            python_version=sys.version,
            platform=platform.system(),
            platform_version=platform.version(),
            cpu_count=psutil.cpu_count(),
            memory_available=psutil.virtual_memory().available if hasattr(psutil, 'virtual_memory') else None,
            disk_free=psutil.disk_usage('/').free if hasattr(psutil, 'disk_usage') else None,
            audio_devices=audio_devices,
            config_hash=config_hash,
            session_id=session_id,
            uptime_seconds=uptime,
        )


@dataclass
class BugReport:
    """A captured bug report."""
    id: Optional[int]
    timestamp: str
    severity: str
    component: str
    title: str
    description: str
    stack_trace: Optional[str]
    system_state: Dict
    user_context: Optional[str]
    status: str
    created_at: str
    updated_at: str
    github_issue: Optional[int]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)
    
    def to_github_issue(self) -> Dict[str, str]:
        """Format for GitHub issue creation."""
        body = f"""## Bug Report

**Severity:** {self.severity}
**Component:** {self.component}
**Status:** {self.status}

### Description
{self.description}

### System State
```json
{json.dumps(self.system_state, indent=2)}
```

### Stack Trace
```
{self.stack_trace or 'No stack trace captured'}
```

### User Context
{self.user_context or 'None provided'}

---
*Auto-generated by Voice Bridge Bug Tracker*
*Report ID: {self.id}*
"""
        # Match test expectations: ["bug", severity, component, "auto-generated"]
        labels = ["bug", self.severity.lower(), f"component:{self.component}", "auto-generated"]
        
        return {
            "title": f"[{self.severity.upper()}] {self.component}: {self.title}",
            "body": body,
            "labels": labels
        }


class BugTracker:
    """
    Automated bug tracking system.
    
    Captures errors with full context, stores locally, and can
    create GitHub issues automatically.
    """
    
    _instance: Optional[BugTracker] = None
    _start_time: Optional[datetime] = None
    
    def __init__(self, db_path: Optional[Path] = None, github_token: Optional[str] = None):
        """
        Initialize bug tracker.
        
        Args:
            db_path: Path to SQLite database (default: ~/.voice-bridge/bugs.db)
            github_token: GitHub token for auto-creating issues (optional)
        """
        if db_path is None:
            db_path = Path.home() / ".voice-bridge" / "bugs.db"
        
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.github_token = github_token
        self.github_repo = "ray1caron/voice-openclaw-bridge-v2"
        self.github_enabled = bool(github_token)
        self.auto_upload_enabled = False  # Auto-create GitHub issues for HIGH/CRITICAL
        
        self._init_db()
        
        BugTracker._start_time = datetime.now()
        
        logger.info(
            "bug_tracker_initialized",
            db_path=str(self.db_path),
            github_enabled=bool(github_token),
        )
    
    @classmethod
    def get_instance(cls) -> BugTracker:
        """Get or create singleton instance."""
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    
    def _init_db(self) -> None:
        """Initialize SQLite database."""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS bugs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    severity TEXT NOT NULL,
                    component TEXT NOT NULL,
                    title TEXT NOT NULL,
                    description TEXT NOT NULL,
                    stack_trace TEXT,
                    system_state TEXT NOT NULL,
                    user_context TEXT,
                    status TEXT NOT NULL DEFAULT 'new',
                    created_at TEXT NOT NULL,
                    updated_at TEXT NOT NULL,
                    github_issue INTEGER
                )
            """)
            
            # Create indexes
            conn.execute("CREATE INDEX IF NOT EXISTS idx_severity ON bugs(severity)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_status ON bugs(status)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_component ON bugs(component)")
            conn.commit()
    
    def capture_error(
        self,
        error: Exception,
        component: str,
        severity: BugSeverity = BugSeverity.HIGH,
        title: Optional[str] = None,
        user_context: Optional[str] = None,
        config=None,
        session_id=None,
        auto_file_github: bool = False,
    ) -> int:
        """
        Capture an error with full context.
        
        Args:
            error: The exception that occurred
            component: Component where error occurred (e.g., "audio", "stt")
            severity: Bug severity level
            title: Optional custom title (defaults to error message)
            user_context: Additional context from user
            config: Current configuration (for hash)
            session_id: Current session ID
            auto_file_github: Automatically create GitHub issue
            
        Returns:
            Bug report ID
        """
        # Capture stack trace
        stack_trace = "".join(traceback.format_exception(type(error), error, error.__traceback__))
        
        # Capture system state
        system_state = SystemSnapshot.capture(config, session_id)
        
        # Create bug report
        now = datetime.now().isoformat()
        bug_title = title if title else str(error)[:100]
        bug = BugReport(
            id=None,
            timestamp=now,
            severity=severity.value,
            component=component,
            title=bug_title,
            description=f"{type(error).__name__}: {str(error)}",
            stack_trace=stack_trace,
            system_state=system_state.__dict__,
            user_context=user_context,
            status=BugStatus.NEW.value,
            created_at=now,
            updated_at=now,
            github_issue=None,
        )
        
        # Save to database
        bug_id = self._save_bug(bug)
        
        logger.error(
            "bug_captured",
            bug_id=bug_id,
            severity=severity.value,
            component=component,
            error_type=type(error).__name__,
            error_message=str(error)[:200],
        )
        
        # Auto-file GitHub issue if enabled (explicit or auto_upload for HIGH/CRITICAL)
        should_file_github = auto_file_github or (
            self.github_enabled and 
            self.auto_upload_enabled and 
            severity in (BugSeverity.HIGH, BugSeverity.CRITICAL)
        )
        
        if should_file_github and self.github_token:
            try:
                issue_num = self._create_github_issue(bug)
                self._update_bug_github_link(bug_id, issue_num)
            except Exception as e:
                logger.error("github_issue_creation_failed", error=str(e))
        elif self.auto_upload_enabled and self.github_token and severity in (BugSeverity.HIGH, BugSeverity.CRITICAL):
            # Background upload for auto-upload mode
            threading.Thread(
                target=self._async_upload_to_github,
                args=(bug_id,),
                daemon=True
            ).start()
        
        return bug_id
    
    def _save_bug(self, bug: BugReport) -> int:
        """Save bug to database."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                INSERT INTO bugs (
                    timestamp, severity, component, title, description,
                    stack_trace, system_state, user_context, status,
                    created_at, updated_at, github_issue
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                bug.timestamp,
                bug.severity,
                bug.component,
                bug.title,
                bug.description,
                bug.stack_trace,
                json.dumps(bug.system_state),
                bug.user_context,
                bug.status,
                bug.created_at,
                bug.updated_at,
                bug.github_issue,
            ))
            conn.commit()
            return cursor.lastrowid
    
    def _update_bug_github_link(self, bug_id: int, issue_num: int) -> None:
        """Update bug with GitHub issue number."""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                "UPDATE bugs SET github_issue = ? WHERE id = ?",
                (issue_num, bug_id)
            )
            conn.commit()
    
    def _create_github_issue(self, bug: BugReport) -> int:
        """Create GitHub issue from bug report."""
        import requests
        
        issue_data = bug.to_github_issue()
        
        headers = {
            "Authorization": f"token {self.github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        response = requests.post(
            f"https://api.github.com/repos/{self.github_repo}/issues",
            headers=headers,
            json=issue_data
        )
        
        if response.status_code == 201:
            return response.json()["number"]
        else:
            raise Exception(f"GitHub API error: {response.status_code} - {response.text}")
    
    def _async_upload_to_github(self, bug_id: int) -> None:
        """Upload bug to GitHub asynchronously in background thread.
        
        Args:
            bug_id: Bug ID to upload
        """
        try:
            bug = self.get_bug(bug_id)
            if bug and not bug.github_issue:
                issue_num = self._create_github_issue(bug)
                self._update_bug_github_link(bug_id, issue_num)
                logger.info(
                    "github_issue_created",
                    bug_id=bug_id,
                    issue_num=issue_num,
                    repo=self.github_repo
                )
        except Exception as e:
            logger.error("async_github_upload_failed", bug_id=bug_id, error=str(e))
    
    def enable_github_upload(
        self, 
        repo: str, 
        token: Optional[str] = None,
        auto_upload: bool = False
    ) -> None:
        """Enable GitHub issue creation with optional auto-upload.
        
        Args:
            repo: GitHub repository (e.g., "owner/repo")
            token: GitHub personal access token (or GITHUB_TOKEN env var)
            auto_upload: Automatically create GitHub issues for HIGH/CRITICAL bugs
        """
        import os
        self.github_token = token or os.getenv("GITHUB_TOKEN")
        self.github_repo = repo
        self.github_enabled = True
        self.auto_upload_enabled = auto_upload
        logger.info(
            "github_upload_enabled",
            repo=repo,
            auto_upload=auto_upload,
            has_token=bool(self.github_token)
        )
    
    def get_bug(self, bug_id: int) -> Optional[BugReport]:
        """Get a bug report by ID."""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute("SELECT * FROM bugs WHERE id = ?", (bug_id,))
            row = cursor.fetchone()
            
            if row:
                return BugReport(
                    id=row["id"],
                    timestamp=row["timestamp"],
                    severity=row["severity"],
                    component=row["component"],
                    title=row["title"],
                    description=row["description"],
                    stack_trace=row["stack_trace"],
                    system_state=json.loads(row["system_state"]),
                    user_context=row["user_context"],
                    status=row["status"],
                    created_at=row["created_at"],
                    updated_at=row["updated_at"],
                    github_issue=row["github_issue"],
                )
            return None
    
    def list_bugs(
        self,
        status: Optional[BugStatus] = None,
        severity: Optional[BugSeverity] = None,
        component: Optional[str] = None,
        limit: int = 100,
    ) -> List[BugReport]:
        """List bugs with optional filtering."""
        query = "SELECT * FROM bugs WHERE 1=1"
        params = []
        
        if status:
            query += " AND status = ?"
            params.append(status.value)
        if severity:
            query += " AND severity = ?"
            params.append(severity.value)
        if component:
            query += " AND component = ?"
            params.append(component)
        
        query += " ORDER BY timestamp DESC LIMIT ?"
        params.append(limit)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute(query, params)
            rows = cursor.fetchall()
            
            bugs = []
            for row in rows:
                bugs.append(BugReport(
                    id=row["id"],
                    timestamp=row["timestamp"],
                    severity=row["severity"],
                    component=row["component"],
                    title=row["title"],
                    description=row["description"],
                    stack_trace=row["stack_trace"],
                    system_state=json.loads(row["system_state"]),
                    user_context=row["user_context"],
                    status=row["status"],
                    created_at=row["created_at"],
                    updated_at=row["updated_at"],
                    github_issue=row["github_issue"],
                ))
            return bugs
    
    def update_status(self, bug_id: int, status: BugStatus) -> bool:
        """Update bug status."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "UPDATE bugs SET status = ?, updated_at = ? WHERE id = ?",
                (status.value, datetime.now().isoformat(), bug_id)
            )
            conn.commit()
            return cursor.rowcount > 0
    
    def export_to_file(self, output_path: Path, format: str = "json") -> None:
        """Export all bugs to file."""
        bugs = self.list_bugs(limit=10000)
        
        if format == "json":
            with open(output_path, "w") as f:
                json.dump([b.to_dict() for b in bugs], f, indent=2)
        elif format == "markdown":
            with open(output_path, "w") as f:
                f.write("# Bug Reports\n\n")
                for bug in bugs:
                    f.write(f"## #{bug.id}: {bug.title}\n\n")
                    f.write(f"- **Severity:** {bug.severity}\n")
                    f.write(f"- **Component:** {bug.component}\n")
                    f.write(f"- **Status:** {bug.status}\n")
                    f.write(f"- **Timestamp:** {bug.timestamp}\n\n")
                    f.write(f"**Description:**\n{bug.description}\n\n")
                    f.write(f"**System State:**\n```json\n{json.dumps(bug.system_state, indent=2)}\n```\n\n")
                    f.write("---\n\n")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get bug statistics."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN status = 'new' THEN 1 ELSE 0 END) as new,
                    SUM(CASE WHEN status = 'fixed' THEN 1 ELSE 0 END) as fixed,
                    SUM(CASE WHEN severity = 'critical' THEN 1 ELSE 0 END) as critical
                FROM bugs
            """)
            row = cursor.fetchone()
            return {
                "total": row[0],
                "new": row[1],
                "fixed": row[2],
                "critical": row[3],
            }

    # Public API methods for testing
    def capture_exception(
        self,
        exception: Exception,
        severity: BugSeverity,
        component: str,
        title: str,
        user_context: Optional[str] = None,
        context: Optional[Dict] = None,
        auto_create_github: bool = False,
    ) -> int:
        """
        Public wrapper to capture an exception as a bug.
        
        Args:
            exception: The exception that occurred
            severity: Bug severity level
            component: Component where error occurred
            title: Bug title
            user_context: Additional context from user
            context: Additional context dict (includes session_id if present)
            auto_create_github: Automatically create GitHub issue
            
        Returns:
            Bug report ID
        """
        session_id = context.get("session_id") if context else None
        bug_id = self.capture_error(
            error=exception,
            component=component,
            severity=severity,
            title=title,
            user_context=user_context,
            session_id=session_id,
            auto_file_github=auto_create_github,
        )
        
        # If GitHub issue was created, the bug record was updated in capture_error
        # Return the bug_id which can be used to get_bug() to check github_issue
        return bug_id

    def create_github_issue(self, bug: BugReport) -> Optional[int]:
        """
        Public wrapper to create a GitHub issue from a bug report.
        
        Includes exponential backoff for rate limiting (429 responses).
        
        Args:
            bug: Bug report to create issue from
            
        Returns:
            GitHub issue number, or None if creation failed
        """
        if not self.github_token:
            return None
            
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                issue_data = bug.to_github_issue()
                
                headers = {
                    "Authorization": f"token {self.github_token}",
                    "Accept": "application/vnd.github.v3+json"
                }
                
                response = requests.post(
                    f"https://api.github.com/repos/{self.github_repo}/issues",
                    headers=headers,
                    json=issue_data
                )
                
                if response.status_code == 201:
                    return response.json()["number"]
                elif response.status_code == 429:
                    # Rate limited - check retry header
                    retry_after = response.headers.get("Retry-After")
                    if retry_after:
                        time.sleep(int(retry_after))
                    else:
                        # Exponential backoff
                        time.sleep(2 ** retry_count)
                    retry_count += 1
                else:
                    raise Exception(f"GitHub API error: {response.status_code}")
                    
            except Exception as e:
                logger.error("github_issue_creation_failed", error=str(e), attempt=retry_count)
                retry_count += 1
                if retry_count >= max_retries:
                    return None
                time.sleep(2 ** retry_count)
        
        return None

    def update_bug_github_issue(self, bug_id: int, issue_num: int) -> bool:
        """
        Public wrapper to update bug record with GitHub issue number.
        
        Args:
            bug_id: Bug ID to update
            issue_num: GitHub issue number
            
        Returns:
            True if update succeeded
        """
        try:
            self._update_bug_github_link(bug_id, issue_num)
            return True
        except Exception as e:
            logger.error("update_bug_github_link_failed", error=str(e))
            return False


# Global exception handler
def install_global_handler(tracker: Optional[BugTracker] = None):
    """Install global exception handler to auto-capture uncaught errors."""
    if tracker is None:
        tracker = BugTracker.get_instance()
    
    original_hook = sys.excepthook
    
    def exception_handler(exc_type, exc_value, exc_traceback):
        """Handle uncaught exceptions."""
        # Capture the error
        try:
            tracker.capture_error(
                error=exc_value,
                component="uncaught",
                severity=BugSeverity.CRITICAL,
                user_context="Uncaught exception - see stack trace",
            )
        except Exception as e:
            logger.error("failed_to_capture_bug", error=str(e))
        
        # Call original handler
        original_hook(exc_type, exc_value, exc_traceback)
    
    sys.excepthook = exception_handler
    
    logger.info("global_exception_handler_installed")


# Convenience functions
def capture_bug(
    error: Exception,
    component: str,
    severity: BugSeverity = BugSeverity.HIGH,
    **kwargs
) -> int:
    """Quick function to capture a bug."""
    tracker = BugTracker.get_instance()
    return tracker.capture_error(error, component, severity, **kwargs)
